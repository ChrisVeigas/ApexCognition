ApexCognition: Deterministic UI Generation Engine
ApexCognition is a hybrid generative system designed to bridge the gap between high-level user intent and production-ready React layouts. It utilizes a Deterministic Logic Layer to ensure reliability for common patterns and an AI-Driven Fallback Layer via Groq for creative, complex requests.

üèóÔ∏è Architecture Overview
The system is built on a "Logic-First" architecture to maximize performance and predictability.
Logic-First Routing: The system first attempts to match prompts against a deterministic engine. If a match is found, the UI is returned instantly with 0ms LLM latency and 100% component accuracy.
Express Backend: A Node.js server serves as the orchestrator, handling environment variables, API routing, and the Vite development middleware.
Vite-React Client: A modern frontend that consumes a custom useDeterministicGroq hook to manage UI state, history (undo/redo), and rendering.
Hybrid State Management: History is managed via a stack-based approach, allowing users to iterate through previous versions of the generated UI.

ü§ñ Agent Design & Prompts
Intent Analysis: Decomposes the prompt to find keywords (e.g., "auth", "dashboard", "charts").
Layout Selection: Chooses between centered, dashboard, split, or fullscreen based on detected complexity.
Component Assembly: Deterministically pushes specific component objects into a hierarchy.
AI Fallback: If no high-confidence match is found, it sends a structured system prompt to Groq.

System Prompt Strategy
When invoking the AI, we use a strict JSON-mode system prompt:
"You are a UI Architect. You must ONLY use the provided component library (Card, Button, Input, Chart, etc.). Return a JSON object matching the AgentPlan interface. Use Tailwind CSS for all styling via the 'className' prop."

Component System Design
The system treats UI as a Serialized Tree. Each component is a standard object:
TypeScript
{
  type: "Card",
  props: { className: "p-6 shadow-md" },
  children: [...]
}
Deterministic Rendering: Every time a user asks for a "Login Page," they receive the optimized structure, ensuring no "hallucinations" in critical paths.
Library Integration: The system is pre-mapped to a robust library of ~40 components including InputOTP, Sidebar, Charts, and NavigationMenu.

Known Limitations
Prop Pass-through: Currently, complex props (like functions or event handlers) are difficult to serialize through the AI layer.
Layout Depth: Deeply nested layouts (more than 5 levels) can occasionally cause rendering performance dips in the DynamicRenderer.
Tailwind Scope: The AI is limited to standard Tailwind classes; custom arbitrary values (e.g., h-[123px]) are sometimes generated incorrectly.

Future Improvements
With more time, I would implement:
Live Code Editing: An integrated Monaco Editor to allow users to manually tweak the JSON/Code generated by the agent.
Visual Regression Testing: Automated snapshots for deterministic templates to ensure library updates never break core UI plans.
Semantic Search for Components: Instead of keyword matching (e.g., .includes("login")), use vector embeddings to find the best component matches for a user's prompt.
Self-Correction Loop: If a generated UI fails to render, the agent should catch the error and automatically re-prompt the LLM with the error stack trace.

Tradeoff: Determinism vs. Creativity: I prioritized a heavy deterministic layer. While this limits "infinite" variety, it ensures that for 80% of business use cases (forms, tables, dashboards), the tool is 100% reliable.
Scoping: I focused on a deep integration with an existing component library rather than building a custom CSS engine from scratch. This allows the agent to produce "real-world" looking UIs immediately.

üõ†Ô∏è Tech Stack
Frontend: React, TypeScript, Tailwind CSS, Vite
Backend: Node.js, Express, TSX
AI Orchestration: Groq SDK (Llama-3.3-70b-versatile)
Environment Management: cross-env, dotenv

Clone the repository:
git clone https://github.com/ChrisVeigas/ApexCognition.git
cd ApexCognition

Install dependencies:
npm install

Environment Configuration:
Create a .env file in the root directory and add your Groq API key:
GROQ_API_KEY=your_gsk_key_here
PORT=3001
NODE_ENV=development

Run the Development Server:
npm run dev
The server will start on http://localhost:3001
